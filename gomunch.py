import time, os, json, re, math, requests

from vaderSentiment import vaderSentiment as vs

def get_origin(ipstack_key=None,
               gmaps_key=None,
               address=None, 
               ipstack_endpoint=r"http://api.ipstack.com/check",
               gmaps_endpoint=r"https://maps.googleapis.com/maps/api/geocode/json"):
    """
    Retrieve GPS coordinates through the following methods:
    - IPStack's Check API via IP address 
    - Google Maps Geocode API via a valid mailing address

    To be used for the 'location' parameter when sending a request to the Google Maps Places Text Search API.
    """
    if address != None:
        payload = {"key": gmaps_key, 
                   "address": address}

        getrequest = requests.get(url=gmaps_endpoint, params=payload)
        getresp = getrequest.json()

        lat = getresp["results"][0]["geometry"]["location"]["lat"]
        lng = getresp["results"][0]["geometry"]["location"]["lng"]

    else:
        payload = {"access_key": ipstack_key, 
                   "hostname": 1}
        
        getrequest = requests.get(url=ipstack_endpoint, params=payload)
        getresp = getrequest.json()
        
        lat = getresp["latitude"]
        lng = getresp["longitude"]
    
    coords = ",".join([str(lat), str(lng)])

    return lat, lng, coords

class GooglePlaceSearch(object):
    """
    Retrieves a query response from Google Maps Place Search API.
    
    Uses GPS coordinates from get_origin() to identify nearby establishments in a given radius.
    
    Distance is set to meters by default. Can be adjusted to be in miles. 
    """
    def __init__(self, 
                 gmaps_key,
                 query,
                 origin_coords,
                 radius,
                 unit="meters",  
                 result_count=40):
    
        self.key = gmaps_key
        self.query = query
        self.origin_coords = origin_coords
        self.radius = radius
        self.unit = unit
        self.result_count = result_count
        self.endpoint_textsearch = r"https://maps.googleapis.com/maps/api/place/textsearch/json"

    def radius_conversion(self): 
        """
        Simple distance conversion of the radius based on the specified unit.
        """   
        if self.unit == "miles":
            return int(self.radius*1609.344)
        elif self.unit == "meters":
            return self.radius

    def result_page_count(self):
        return math.ceil(self.result_count/20)

    def google_searchquery(self):
        """
        Sends and retrieves the query response generated by the Place Search API.
        
        Parses out the data in the responses into a dictionary. 
        """
        payload = {"key": self.key,
                   "query": self.query,
                   "location": self.origin_coords,
                   "radius": self.radius_conversion()}

        page_counter = 0
        list_responses = []

        while page_counter <= self.result_page_count():
            try:
                getrequest = requests.get(self.endpoint_textsearch, params=payload)
                getresp = getrequest.json()
                list_responses.extend(getresp["results"])  

                payload = {"key": self.key, 
                           "pagetoken": getresp["next_page_token"]}
                page_counter+=1
                time.sleep(10)
                
            except KeyError:
                break

        query_range = range(0, len(list_responses))
        
        dict_query = {"place_id": [],
                      "name": [],
                      "address": [],
                      "city": [],
                      "state": [],
                      "zip": [],
                      "lat": [],
                      "lng": [],
                      "open_now": [],
                      "goog_price_level": [],
                      "goog_rating": [],
                      "goog_rating_count": [],
                      "type_of_place": []
                     }
        
        #Business data
        [dict_query["place_id"].append(list_responses[i]["place_id"]) for i in query_range]
        [dict_query["name"].append(list_responses[i]["name"]) for i in query_range]
        [dict_query["open_now"].append(list_responses[i]["opening_hours"]["open_now"] if "opening_hours" in list_responses[i].keys() else None) for i in query_range]
        [dict_query["type_of_place"].append(sorted(list_responses[i]["types"] if "types" in list_responses[i].keys() else None)) for i in query_range]

        #Location data
        [dict_query["address"].append(" ".join(list_responses[i]["formatted_address"].split(", ")[:-3])) for i in query_range]
        [dict_query["city"].append(list_responses[i]["formatted_address"].split(", ")[-3]) for i in query_range]
        [dict_query["state"].append(list_responses[i]["formatted_address"].split(", ")[-2].split(" ")[0]) for i in query_range]
        [dict_query["zip"].append(list_responses[i]["formatted_address"].split(", ")[-2].split(" ")[1]) for i in query_range]
        [dict_query["lat"].append(list_responses[i]["geometry"]["location"]["lat"]) for i in query_range]
        [dict_query["lng"].append(list_responses[i]["geometry"]["location"]["lng"]) for i in query_range]

        #Business ratings
        [dict_query["goog_price_level"].append(list_responses[i]["price_level"] if "price_level" in list_responses[i].keys() else None) for i in query_range]
        [dict_query["goog_rating"].append(list_responses[i]["rating"] if "rating" in list_responses[i].keys() else None) for i in query_range]
        [dict_query["goog_rating_count"].append(list_responses[i]["user_ratings_total"] if "user_ratings_total" in list_responses[i].keys() else None) for i in query_range]
        
        return dict_query

class GoogleBusinessInfo(object):

    def __init__(self, 
                 gmaps_key, 
                 place_ids,
                 origin_coords):

        self.key = gmaps_key
        self.place_ids = place_ids
        self.origin_coords = origin_coords
        self.endpoint_details = r"https://maps.googleapis.com/maps/api/place/details/json"
        self.endpoint_distmatrix = r"https://maps.googleapis.com/maps/api/distancematrix/json"

    def google_busdetails(self, place_id):
        """
        Retrieves the following information of an establishment by their Google Place ID:
        - Reviews
        - Formatted phone number
        - International phone number
        - Businses opening hours
        - Website
        """
        payload = {"key": self.key,
                   "placeid": place_id,
                   "fields": ",".join(["reviews",
                                       "formatted_phone_number", 
                                       "international_phone_number", 
                                       "opening_hours", 
                                       "website"]),
                   "language": "en"
                  }

        getrequest = requests.get(url=self.endpoint_details, params=payload)
        getresp = getrequest.json()
        
        return getresp

    def distance_time(self, place_id):
        """
        Retrieve distance and time to a destination from origin GPS coordinates at execution time.
        
        Distance returned is in meters.
        
        Time returned is in seconds.
        """
        payload = {"key": self.key, 
                   "origins": self.origin_coords, 
                   "destinations": "place_id:" + place_id,
                   "departure_time": "now",
                   "traffic_model": "best_guess", 
                   "mode": "driving"
                  }    
        
        getrequest = requests.get(url=self.endpoint_distmatrix, params=payload)
        getresp = getrequest.json()
        
        distance = getresp["rows"][0]["elements"][0]["distance"]["value"]
        time = getresp["rows"][0]["elements"][0]["duration"]["value"]
        
        return distance, time

    def google_businfo(self, return_hours=False):
        """
        Parse the responses from get_details() and get_distance_time() into a dictionary for each Google Maps Place ID.
        """
        #TODO: Find a simpler way to return hours of operation data.
        dict_businfo = {"place_id": self.place_ids, 
                        "phone_formatted": [], 
                        "phone": [],
                        "site": [], 
                        "distance": [], 
                        "trip_time": [], 
                        "goog_sent_pos": [], 
                        "goog_sent_neu": [], 
                        "goog_sent_neg": [],
                        "goog_sent_comp": [],
                        "goog_rev_avgrating": []
                        }
        
        sent_scorer = vs.SentimentIntensityAnalyzer()

        for _id in self.place_ids:
            details = self.google_busdetails(place_id=_id)
            dist_time = self.distance_time(place_id=_id)
            
            dict_businfo["phone_formatted"].append(details["result"]["formatted_phone_number"] if "formatted_phone_number" in details["result"].keys() else None)
            dict_businfo["phone"].append(details["result"]["international_phone_number"] if "formatted_phone_number" in details["result"].keys() else None)
            dict_businfo["phone"] = [re.sub(pattern=r"[^\d\+]", repl="", string=x) if x is not None else None for x in dict_businfo["phone"]]
            dict_businfo["site"].append(details["result"]["website"] if "website" in details["result"].keys() else None)
            
            dict_businfo["distance"].append(dist_time[0])
            dict_businfo["trip_time"].append(dist_time[1])
            
            if "reviews" not in details["result"].keys():
                for k in ["goog_sent_pos", "goog_sent_neu", "goog_sent_neg", "goog_sent_comp", "goog_rev_avgrating"]:
                    dict_businfo[k].append(None)
            else:
                reviews = details["result"]["reviews"]
                sent_scores = [sent_scorer.polarity_scores(r["text"]) for r in reviews]

                dict_businfo["goog_sent_pos"].append(sum(s["pos"] for s in sent_scores)/len(sent_scores))
                dict_businfo["goog_sent_neu"].append(sum(s["neu"] for s in sent_scores)/len(sent_scores))
                dict_businfo["goog_sent_neg"].append(sum(s["neg"] for s in sent_scores)/len(sent_scores))
                dict_businfo["goog_sent_comp"].append(sum(s["compound"] for s in sent_scores)/len(sent_scores))
                dict_businfo["goog_rev_avgrating"].append(sum(r["rating"] for r in reviews)/len(reviews))
            
            if return_hours:
                sun_open, mon_open, tue_open, wed_open, thur_open, \
                fri_open, sat_open, sun_close, mon_close, tue_close, \
                wed_close, thur_close, fri_close, sat_close = [], [], [], [], [], [], [], [], [], [], [], [], [], []

                opens = [sun_open, mon_open, tue_open, wed_open, thur_open, fri_open, sat_open]
                closes = [sun_close, mon_close, tue_close, wed_close, thur_close, fri_close, sat_close]

                day_idx = {"sun": 0, "mon": 1, "tue": 2, "wed": 3, "thur": 4, "fri": 5, "sat": 6}
                
                for day in day_idx.keys():
                    try:
                        opens[day_idx[day]].append(details["result"]["opening_hours"]["periods"][day_idx[day]]["open"]["time"])
                    except:
                        opens[day_idx[day]].append(None)
                    try:
                        closes[day_idx[day]].append(details["result"]["opening_hours"]["periods"][day_idx[day]]["close"]["time"])
                    except:
                        closes[day_idx[day]].append(None)
                        
                for day in day_idx.keys():
                    dict_businfo["opens_"+day] = opens[day_idx[day]]
                    dict_businfo["closes_"+day] = closes[day_idx[day]]

        return dict_businfo

    
class YelpMatch(object):
    def __init__(self,
                 yelp_key,  
                 radius_in_meters=100):

        self.key = yelp_key
        self.endpoint_base = r"https://api.yelp.com/v3/businesses"
        self.endpoint_match = self.endpoint_base + r"/matches"
        self.radius = radius_in_meters
        self.headers = {"Authorization": "Bearer " + self.key}

    def google_yelp_match(self, 
                          google_query_result, 
                          google_businfo_result,
                          country
                         ):
        """
        Passes business information retrieved from the Google Maps Text Search API to
        Yelp's Business Match API endpoint.

        Returns a list of dictionaries of the corresponding Google Maps Place ID to the
        Yelp Business ID.
        """
        id_matches = []

        for i in range(len(google_query_result["place_id"])):

            payload = {"name": google_query_result["name"][i], 
                       "address1": google_query_result["address"][i], 
                       "city": google_query_result["city"][i], 
                       "state": google_query_result["state"][i],
                       "zip": google_query_result["zip"][i],
                       "latitude": google_query_result["lat"][i],
                       "longitude": google_query_result["lng"][i],
                       "country": country,
                       "phone": google_businfo_result["phone"][i],
                       "matching_threshold": "strict"
                      }

            getrequest = requests.get(url=self.endpoint_match, 
                                      headers=self.headers, 
                                      params=payload
                                     )

            getresp = getrequest.json()

            try:
                get_business = getresp["businesses"][0]
                match = {"yelp_id": get_business["id"], "place_id": google_query_result["place_id"][i]}
                id_matches.append(match)
            except:
                id_matches.append({"place_id": google_query_result["place_id"][i]})

        return id_matches
    
    def yelp_businfo(self, _id):
        endpoint_business = "/".join([self.endpoint_base, _id])

        getrequest = requests.get(url=endpoint_business, 
                                  headers=self.headers, 
                                  params={"locale": "en_US"}
                                 )

        return getrequest.json()
        
    def yelp_searchquery(self, id_match_list):
        dict_query = {"place_id": [], 
                      "yelp_id": [], 
                      "name": [],
                      "yelp_price_level": [], 
                      "yelp_rating": [], 
                      "yelp_rating_count": []
                     }

        list_responses = []

        for _ids in id_match_list:
            if "yelp_id" in _ids.keys():
                info = self.yelp_businfo(_ids["yelp_id"])
                pull_status = "name" in info.keys()
                
                if pull_status == False:
                    while pull_status == False:
                        time.sleep(15)
                        info = self.yelp_businfo(_ids["yelp_id"])
                        pull_status = "name" in info.keys()

                dict_query["place_id"].append(_ids["place_id"])
                dict_query["yelp_id"].append(_ids["yelp_id"])
                dict_query["name"].append(info["name"])
                dict_query["yelp_price_level"].append(len(info["price"]) if "price" in info.keys() else None)
                dict_query["yelp_rating"].append(info["rating"])
                dict_query["yelp_rating_count"].append(info["review_count"])
            else:
                dict_query["place_id"].append(_ids["place_id"])
                for key in list(dict_query.keys())[1:]:
                    dict_query[key].append(None)
                    
            time.sleep(15)

        return dict_query


    def yelp_sentiment(self,
                       id_match_list
                      ):

        dict_sentiment = {"place_id": [], 
                          "yelp_id": [],
                          "yelp_sent_pos": [],
                          "yelp_sent_neu": [],
                          "yelp_sent_neg": [],
                          "yelp_sent_comp": [],
                          "yelp_rev_avgrating": []
                         }

        sent_scorer = vs.SentimentIntensityAnalyzer()

        for _ids in id_match_list:
            if "yelp_id" in _ids.keys():
                endpoint_reviews = "/".join([self.endpoint_base, _ids["yelp_id"], "reviews"])

                getrequest = requests.get(url=endpoint_reviews, 
                                          headers=self.headers
                                         )

                try:
                    getresp = getrequest.json()["reviews"]   

                    #Yelp review text snippets end in trailing elipsis, hence the [:-3] slice notation.
                    texts = [r["text"][:-3] for r in getresp]

                    dict_sentiment["place_id"].append(_ids["place_id"])
                    dict_sentiment["yelp_id"].append(_ids["yelp_id"])
                    dict_sentiment["yelp_sent_pos"].append(sum([sent_scorer.polarity_scores(t)["pos"] for t in texts])/len(texts))
                    dict_sentiment["yelp_sent_neu"].append(sum([sent_scorer.polarity_scores(t)["neu"] for t in texts])/len(texts))
                    dict_sentiment["yelp_sent_neg"].append(sum([sent_scorer.polarity_scores(t)["neg"] for t in texts])/len(texts))
                    dict_sentiment["yelp_sent_comp"].append(sum([sent_scorer.polarity_scores(t)["compound"] for t in texts])/len(texts))
                    dict_sentiment["yelp_rev_avgrating"].append(sum([r["rating"] for r in getresp])/len(getresp))

                except:
                    dict_sentiment["place_id"].append(_ids["place_id"])
                    dict_sentiment["yelp_id"].append(_ids["yelp_id"])
                    [dict_sentiment[key].append(None) for key in list(dict_sentiment.keys())[2:]]
            else:
                dict_sentiment["place_id"].append(_ids["place_id"])
                [dict_sentiment[key].append(None) for key in list(dict_sentiment.keys())[1:]]

        return dict_sentiment
        